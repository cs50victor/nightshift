Goal
- Implement teams.db in the nightshift daemon per `daemon/teams_db.spec.txt`.
- Replace JSON watcher state with a sqlx-backed SQLite database.
- Expose new read/write HTTP APIs on the daemon proxy.
- Do not modify the public `claude-code-teams-mcp` repo.

Scope and Constraints
- Only change the nightshift repo (`/Users/vic8or/dev/nightshift`).
- Use sqlx with SQLite (async tokio runtime) and embedded migrations.
- Add UUID ids using the `uuid` crate.
- Retention cleanup runs only at daemon startup.
- Keep `rusqlite` for read-only access to OpenCodeâ€™s `opencode.db`.
- Preserve existing daemon behavior unrelated to teams (watchdog, update, node registration).

Current Architecture Summary (for context)
- Daemon starts `opencode serve` on port 19276 and runs an axum proxy on 19277.
- Proxy currently includes `/teams`, `/teams/{team}/members/{name}/diff`, and `/teams/{team}/members/{name}/tools`.
- Team state today is read from JSON files in `~/.claude/teams` and `~/.claude/tasks`.
- Tool call history is read from:
  - OpenCode SQLite (`opencode.db`, table `part`, JSON tool parts)
  - Claude Code JSONL transcripts

Target Architecture Summary
- `teams.db` at `~/.nightshift/teams.db` (override via `NIGHTSHIFT_TEAMS_DB_PATH`).
- Daemon is the sole writer to `teams.db`.
- All MCP tool operations are served by daemon `/internal/*` endpoints.
- JSON watcher (`daemon/src/teams.rs`) is removed or reduced to shared helpers.
- Tool ingestion writes into `teams.db` and uses `ingest_cursors` for idempotency.

Key Files (must understand before implementing)
- `daemon/teams_db.spec.txt` (authoritative schema, routes, invariants)
- `daemon/src/daemon.rs` (startup, opencode spawn, proxy serve)
- `daemon/src/proxy.rs` (routes, OpenAPI, AppState)
- `daemon/src/teams.rs` (JSON watcher and API types to be replaced)
- `daemon/src/toolcalls.rs` (tool parsing and history)
- `daemon/Cargo.toml` (dependencies)
- `daemon/tests/openapi_proxy_blast.rs` (expects `/teams` returns 200)

Implementation Plan

1) Database foundation
- Add dependencies in `daemon/Cargo.toml`:
  - `sqlx = { version = "0.8", features = ["runtime-tokio", "sqlite", "migrate", "macros"] }`
  - `uuid = { version = "1", features = ["v4"] }`
- Add migrations directory and file:
  - `daemon/migrations/0001_teams_db.sql`
  - Include all CREATE TABLE + INDEX statements from spec Section D verbatim.
- Add `daemon/src/db.rs` with:
  - `open(path: &Path) -> SqlitePool`:
    - Use `SqlitePoolOptions`.
    - Use `after_connect` to apply pragmas on every connection:
      - journal_mode=WAL
      - synchronous=NORMAL
      - foreign_keys=ON
      - busy_timeout=5000
      - temp_store=MEMORY
  - `run_migrations(pool)` using `sqlx::migrate!()`.
  - `reconcile_on_boot(pool)`:
    - Close any `member_runs` with `ended_at_ms IS NULL` (set ended_at_ms = boot_time, end_reason = "unknown").
    - Cancel any `tool_calls` with status "started" (set status = "cancelled", ended_at_ms = boot_time).
    - Set all `member_status_current` rows to `alive = 0`, `state = "offline"`.
  - `retention_cleanup(pool)`:
    - Read env: `NIGHTSHIFT_STATUS_RETENTION_DAYS` (default 30), `NIGHTSHIFT_ACTIVITY_RETENTION_DAYS` (default 90).
    - Delete old rows in `member_status_events` and `activity_log` based on created_at_ms cutoff.

2) Create DB-backed repository layer
- Add `daemon/src/teams_repo.rs` and move response/request types here.
- Define API types with serde + utoipa, using `#[serde(rename_all = "camelCase")]`.
- Implement write operations (each in a single transaction):
  - `create_team`: insert into `teams`, insert lead member into `members`, create `member_status_current` for lead, add activity_log.
  - `delete_team`: ensure no non-lead members; delete team row (cascade).
  - `spawn_teammate`: insert member, create member_run, update status, add activity_log.
  - `kill_teammate`: end run, mark member removed_at_ms, update status, add activity_log.
  - `create_task`, `update_task` (with metadata merge), `send_message`, `mark_read`.
  - `upsert_status`, `append_status_event`, `insert_tool_call`, `update_tool_call`.
- Implement read operations:
  - `list_teams`: active + archived list using `teams.archived_at_ms`.
  - `get_team_snapshot`: teams, members, tasks, status, conflict detection.
  - `get_activity`: read `activity_log` by team_id and `since_ms`/`limit`.
  - `get_member_timeline`: `member_status_events` by member.
  - `get_member_tools`: read from `tool_calls`, with tool stats aggregation.
- ID generation:
  - Use `Uuid::new_v4().to_string()` for primary keys in new tables.

3) Git diff support
- Preserve the existing diff endpoint `/teams/{team}/members/{name}/diff`.
- Move git helpers from `daemon/src/teams.rs` into a new module `daemon/src/diff.rs` or a slimmed `teams.rs`:
  - `git_head`, `compute_diff_summary`, `compute_diff_full`, `parse_numstat`, `parse_name_status`.
- Fetch member `cwd` from DB (members table) to compute diffs.
- Baseline:
  - On member create, store `baseline_commit` in a new column if needed, or reuse existing `member_runs` to store baseline.
  - If no baseline, diff returns empty string (same as current behavior).

4) Wire DB into daemon startup and proxy
- `daemon/src/main.rs`:
  - Add `mod db;` and `mod teams_repo;` (and `mod diff;` if created).
- `daemon/src/daemon.rs`:
  - Compute `teams.db` path from `NIGHTSHIFT_TEAMS_DB_PATH` or `~/.nightshift/teams.db`.
  - `db::open` -> `db::run_migrations` -> `db::reconcile_on_boot` -> `db::retention_cleanup` before proxy start.
  - Remove `TeamsHandle` creation and JSON watcher spawn.
  - Spawn ingestion worker and status worker as tokio tasks.
  - Pass `SqlitePool` into `proxy::serve`.
- `daemon/src/proxy.rs`:
  - Replace `AppState.teams` with `AppState.db: Arc<SqlitePool>`.
  - Update existing handlers to query via `teams_repo`.
  - Add all `/internal/*` POST handlers and new read endpoints.
  - Ensure `api_router` and `daemon_openapi_json` register all new routes.

5) Tool ingestion and cursors
- `daemon/src/toolcalls.rs`:
  - Keep `read_opencode_tools` and `read_claude_tools` as parsers.
  - Add ingestion functions:
    - Load cursor from `ingest_cursors` per member/source.
    - Read new tool calls since cursor.
    - Insert into `tool_calls` (dedupe by unique index).
    - Update cursor in same transaction.
  - Respect `NIGHTSHIFT_STORE_RAW_INPUTS=1`:
    - Store `input_json` if enabled.
    - Redact obvious secrets before storing (simple regex pass).

6) Remove JSON watcher state
- Remove JSON watcher, active-sessions resolution, and archive logic from `daemon/src/teams.rs`.
- Keep only shared types or diff helpers if still referenced by proxy.
- Update or remove unit tests in `daemon/src/teams.rs` that only validate JSON parsing.

7) Tests and verification behavior
- Ensure `/teams` still returns 200 for `daemon/tests/openapi_proxy_blast.rs`.
- Add minimal unit tests for:
  - `db::reconcile_on_boot` (can use temp sqlite file).
  - `teams_repo` transaction behavior (e.g., create_team adds activity_log).
- Avoid heavy integration tests unless required.

Decisions Already Set
- Only change nightshift repo.
- Use UUIDs for primary keys.
- Retention cleanup runs at daemon startup only.

Verification Steps
1) Run tests:
   - `cargo test -p nightshift-daemon`
2) Manual smoke check (temp HOME):
   - Start daemon with `HOME` pointing to a temp dir.
   - `GET /teams` returns empty list.
   - `POST /internal/teams/create` creates a team.
   - `GET /teams/{team}/snapshot` returns team + lead member.
   - `POST /internal/tasks/create` and `GET /teams/{team}/snapshot` show task.
3) Verify `~/.nightshift/teams.db` exists and `_sqlx_migrations` is populated.

Notes
- MCP adapter remains unchanged. It can be updated later to call `/internal/*`.
- If you want a single-file uv script MCP adapter later, implement after daemon APIs stabilize.
